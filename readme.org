* OOD
** GoF Design Patterns
   https://refactoring.guru/design-patterns/catalog
*** Creational
**** Singleton
     Asserts that the whole application will have single inctance
     of certain object. The access to the object goes through the
     'get_instance..' method. Has side effects.

**** Builder
     Defines process of step by step building of complex object
     with bunch of pre-defined options. After the object has 
     created, it may be used. (e.g. HTTP Client with different 
     options like retrying, tracking mechanism, custom transport, 
     tls/ssl)

**** Factory
     Creates different objects with common interface depending of
     input options. (e.g. Authentication object with method Auth
     but with different grant_types: client-credentials, 
     authorization_code)

**** Abstrat factory
     Use the Abstract Factory when your code needs to work with
     various families of related products, but you don’t want it 
     to depend on the concrete classes of those products—they 
     might be unknown.

     | car interface     |
     |-------------------|
     | + CreateCar       |
     | + CreateEngine    |
     |-------------------|
     | BMW interface     |
     |-------------------|
     | + CreateCar       |
     | + CreateEngine    |
     |-------------------|
     | Citroen interface |
     |-------------------|
     | + CreateCar       |
     | + CreateEngine    |

**** Prototype
     Clone() object in current state

*** Structural
**** Adapter
     Used in places where some 3rd-party code expects different
     interface programm has.
     - Middle layer class that extends existing class
     - (Go) Function that receives existsing class and returns
       needed one.
     
**** Bridge [Mocks]
     Composition.
     Way to set apart usage and implementation of object (interface).
     Parent struct doesn't care about implementation.
    
**** Composite 
     Tree-like interface structure. Interface has methods to 
     add/remove objects with SAME interface. The implementation 
     struct contains the list of subtrees.
     
     #+begin_src bash
            [i]
           / | \
     [i]-[i][i][i]-[i]
          /  |  \
         [i][i][i]
     #+end_src
         
**** Decorator 
     Wraps behavior of method (function) and extends it.
     - Composition 
       Implement original interface (type SomeAdapter struct{..})
     - Function 
       Receive and return same fn schema, execute it insade 
       and extend
       
**** Facade [incapsulation]
     Hide implementation complexity behind simple interface
     (interface here in generally)
     
**** Flyweight (Cache)
     Save initialized (computed) ojects (info) insade object
     to reuse it in future instead of create (compute) it again.
     (like variables actually)
     
**** Proxy
     Creates "wrapper" around of some object. PROXY OBJECT 
     HAS TO IMPLEMENT ORIGINAL'S OBJECT INTERFACE. Proxy intercepts
     calls to the real object before or after and can extend, 
     perform validation, cache etc.

*** Behavioral
**** Chain of responsibility [middlewares]
     Chain of object with same interface. Usually has method "next"
     - If one part of chain fails, no further processing performs.
     - Different way - stop processing on success.

**** Command [delegation]
     Sender -> Command -> Receiver
     Creates middle layer set of commands where every command 
     represented by its own class with common interface. (usually
     with one method "Execute()") It requires additional layer to
     bound Commands to Senders. On initialization, Command gets 
     Receiver's instance. After that command may be assigned to 
     Sender. Sender stores a list of Commands, and methods to add,
     remove and execute them, this allows dinamically change Sender's 
     behavior.
     
     #+begin_src bash
     Senders
     [] [] [] [] [] []
         Commands
         [] [] []
            Receiver
            []
     #+end_src

**** Iterator
     The most fucking complicated pattern used in complex data 
     structures like trees. Move iteration over elements to its own
     class, so data structure doesn't know about it. Allows to 
     easily implement different iteration methods for complex data.

**** Mediator
     Mediator restricts direct communications between the objects and 
     forces them to collaborate only via a mediator object. Solution 
     for tightly coupled objects.

     #+begin_src go
     package main

     import "fmt"
     
     func main() {
       httpStream := new(HTTPStream)
       grpcStream := new(GRPCStream)
       streamMediator := StreamMediator{
         HTTPStream: httpStream,
         GRPCStream: grpcStream,
       }
       httpStream.Mediator = streamMediator
       httpStream.IsAlive = true
       grpcStream.Mediator = streamMediator
       grpcStream.IsAlive = true
       httpStream.Cancell()
     }
     
     const (
       HTTPStreamCancelled = iota
       GRPCStreamCancelled
     )
     
     type Mediator interface {
       Notify(int)
     }
     
     type StreamMediator struct {
       HTTPStream *HTTPStream
       GRPCStream *GRPCStream
     }
     
     func (m StreamMediator) Notify(i int) {
       switch i {
       case HTTPStreamCancelled:
         m.GRPCStream.Cancell()
       case GRPCStreamCancelled:
         m.HTTPStream.Cancell()
       }
     }
     
     type HTTPStream struct {
       Mediator Mediator
       IsAlive  bool
     }
     
     func (s *HTTPStream) Cancell() {
       if s.IsAlive {
         s.IsAlive = false
         s.Mediator.Notify(HTTPStreamCancelled)
         fmt.Println("HTTP stream cancelled")
       }
     }
     
     type GRPCStream struct {
       Mediator Mediator
       IsAlive  bool
     }
     
     func (s *GRPCStream) Cancell() {
       if s.IsAlive {
         s.IsAlive = false
         s.Mediator.Notify(GRPCStreamCancelled)
         fmt.Println("GRPC stream cancelled")
       }
     }
     #+end_src
* Programming language
** Stack and Heap
   https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/

   Go allocates memory in two places: a global heap for dynamic 
   allocations and a local stack for each goroutine. Go prefers 
   allocation on the stack — most of the allocations within a 
   given Go program will be on the stack. It’s cheap because it 
   only requires two CPU instructions: one to push onto the 
   stack for allocation, and another to release from the stack.
    
   Heap - is the global memory of programm. If function creates 
   a vairable and returns reference to it, the variable allocates
   in heap.
    
   Stack - is local memory allocated for function (per goroutine).
   It has its own top that moves up and down for each nested call.
   This memory is freed once function is returned.
    
   Compiler is smart anough to determine if variable has to be 
   allocated in stack or in heap, it performs `escape analysis`
   - set of rules that vairable must pass on compilation stage.
   If it doesn't it will be allocated in heap.

   Go prefers allocation on the stack — most of the allocations 
   within a given Go program will be on the stack. It’s cheap 
   because it only requires two CPU instructions: one to push 
   onto the stack for allocation, and another to release from the 
   stack.
  
   Stack allocation requires that the lifetime and memory footprint
   of a variable can be determined at compile time. Otherwise a 
   dynamic allocation onto the heap occurs at runtime. `malloc` 
   must search for a chunk of free memory large enough to hold the 
   new value. Later down the line, the garbage collector scans the 
   heap for objects which are no longer referenced.

   The rule of thumb is: pointers point to data allocated on the heap.
   Thus, reducing the number of pointers in a program reduces the 
   number of heap allocations.
** Interfaces: Interface Values, Type Assertions
   https://research.swtch.com/interfaces
   https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md
   Interface is an abstract data type, that doesn't expose the representation
   of internal structure. When you have a value of an interface type, you know 
   nothing about what it is, you know only what it can do. (Duck typing).
    
   Interface: 64bit
   - pointer to "itable"
     - metadata describing type
     - type's hash for type switch (switch x.(type))
     - flag that describes if interface is implemented
     - list of method names and their types
   - data: 
     - "unsafe.Pointer" to copy of original data in heap
        
   If the interface type has no methods then the itable serves no purpose 
   except to hold the pointer to the original type. In this case, the 
   itable can be dropped and the value can point at the type directly

   If the value associated with the interface value can fit in a single machine 
   word, there's no need to introduce the indirection or the heap allocation. 
   If we define Binary32 to be like Binary but implemented as a uint32, 
   it could be stored in an interface value by keeping the actual value.
    
   Compiler calculates itabels for static interfaces at compilation phase. 
   Dynamic allocation performs on type assertions. (Probably).
    
   #+begin_src go
   // src/runtime/runtime2.go
   type iface struct { // 16 bytes on a 64bit arch
     tab  *itab
     data unsafe.Pointer // copy of original data in heap
   }

   // src/runtime/runtime2.go
   type itab struct { // 40 bytes on a 64bit arch
     inter *interfacetype
     // internal representation of any Go type within the runtime,
     // describes the type of the value held by the interface.
     _type *_type
     hash  uint32 // copy of _type.hash. Used for type switches.
     _     [4]byte // WTF?
     fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
   }
    
   // src/runtime/type.go
   type interfacetype struct { // 80 bytes on a 64bit arch
     typ     _type
     pkgpath name
     mhdr    []imethod
   }

   type imethod struct {
     name nameOff
     ityp typeOff
   }
   #+end_src
 
   Interface values may be compared using == and !=. Two interface values are equal if both are
   nil, or if their dynamic types are identical and their dynamic values are equal according to the
   usual behavior of == for that type. Because interface values are comparable, they may be used
   as the keys of a map or as the operand of a switch statement. However, if two interface values 
   are compared and have the same dynamic type, but that type is not comparable (a slice, map or 
   function for instance), then the comparison fails with a panic.
    
   A nil interface value, which contains no value at all, is not the same as an interface value 
   containing a pointer that happens to be nil. 
    
   #+begin_src go
   type xi interface{}
   var a *string = nil
   var x xi = a
   fmt.Println(x == nil) // false
   #+end_src

* Profile
  There are two pprof implementations available:
  - net/http/pprof
  - runtime/pprof
  OR
  - Dave Cheney's profiler: (extremely awesome)
    https://github.com/pkg/profile

  #+begin_src go
  import "runtime/pprof"

  // somewhere in code:
  fn := filepath.Join("cpu.pprof")
  file, err := os.Create(fn) // create file for profiler output
  pprof.StartCPUProfile(file) // start CPU Profiler
  defer pprof.StopCPUProfile() // write results to the file
  #+end_src

  web view:
  #+begin_src bash
  $ go tool pprof -http=:8080 cpu.pprof
  #+end_src
